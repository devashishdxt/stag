use std::path::Path;

use anyhow::{Context, Result};
use clap::Subcommand;
use stag_api::types::ics::core::ics24_host::identifier::{ChainId, Identifier, PortId};

use crate::util::stag;

#[derive(Debug, Subcommand)]
pub enum QueryCommand {
    /// Fetches on-chain balance of a given denom
    Balance {
        /// Chain ID
        chain_id: ChainId,
        /// Denom of tokens
        denom: Identifier,
        /// True if given denom is an IBC denom generated by solo machine
        #[clap(short, long)]
        ibc_denom: bool,
    },
    /// Fetches current stored state for a given chain
    Chain {
        /// Chain ID
        chain_id: ChainId,
    },
    /// Fetches all the stored chain states
    AllChains {
        /// Number of items to fetch
        #[clap(long)]
        limit: Option<u32>,
        /// Offset of items to fetch
        #[clap(long)]
        offset: Option<u32>,
    },
    /// Fetches the final denom of a token on solo machine after sending it on given chain
    IbcDenom {
        /// Chain ID
        chain_id: ChainId,
        /// Denom on solo machine
        denom: Identifier,
    },
    /// Fetches on-chain ICA (Interchain Account) address
    IcaAddress {
        /// Chain ID
        chain_id: ChainId,
    },
    /// Fetches transaction history of given chain
    History {
        /// Chain ID
        chain_id: ChainId,
        /// Number of items to fetch
        #[clap(long)]
        limit: Option<u32>,
        /// Offset of items to fetch
        #[clap(long)]
        offset: Option<u32>,
    },
    /// Fetches all the historical public keys associated with solo machine client on given chain
    PublicKeys {
        /// Chain ID
        chain_id: ChainId,
        /// Number of items to fetch
        #[clap(long)]
        limit: Option<u32>,
        /// Offset of items to fetch
        #[clap(long)]
        offset: Option<u32>,
    },
}

impl QueryCommand {
    pub async fn run(self, signer: impl AsRef<Path>, db_uri: &str) -> Result<()> {
        match self {
            Self::Balance {
                chain_id,
                denom,
                ibc_denom,
            } => {
                let balance = if ibc_denom {
                    stag(signer, db_uri)
                        .await?
                        .get_ibc_balance(&chain_id, &PortId::transfer(), &denom)
                        .await
                } else {
                    stag(signer, db_uri)
                        .await?
                        .get_balance(&chain_id, &denom)
                        .await
                }?;

                println!("current balance: {} {}", balance, denom);

                Ok(())
            }
            Self::Chain { chain_id } => {
                let chain_state = stag(signer, db_uri).await?.get_chain(&chain_id).await?;

                match chain_state {
                    None => println!("chain with ID {} not found", chain_id),
                    Some(chain_state) => {
                        let chain_state = serde_yaml::to_string(&chain_state)
                            .context("failed to serialize chain state")?;

                        println!("{chain_state}");
                    }
                }

                Ok(())
            }
            Self::AllChains { limit, offset } => {
                let chains = stag(signer, db_uri)
                    .await?
                    .get_all_chains(limit, offset)
                    .await
                    .context("failed to fetch chain states")?;

                let chains =
                    serde_yaml::to_string(&chains).context("failed to serialize chain states")?;

                println!("{chains}");

                Ok(())
            }
            Self::IbcDenom { chain_id, denom } => {
                let denom = stag(signer, db_uri)
                    .await?
                    .get_ibc_denom(&chain_id, &PortId::transfer(), &denom)
                    .await
                    .context("failed to fetch ibc denom")?;

                println!("{denom}");

                Ok(())
            }
            Self::IcaAddress { chain_id } => {
                let ica_address = stag(signer, db_uri)
                    .await?
                    .get_ica_address(&chain_id)
                    .await
                    .context("failed to fetch ica address")?;

                println!("{ica_address}");

                Ok(())
            }
            Self::History {
                chain_id,
                limit,
                offset,
            } => {
                let history = stag(signer, db_uri)
                    .await?
                    .get_history(&chain_id, limit, offset)
                    .await
                    .context("failed to fetch history")?;

                let history =
                    serde_yaml::to_string(&history).context("failed to serialize history")?;

                println!("{history}");

                Ok(())
            }
            Self::PublicKeys {
                chain_id,
                limit,
                offset,
            } => {
                let public_keys = stag(signer, db_uri)
                    .await?
                    .get_public_keys(&chain_id, limit, offset)
                    .await
                    .context("failed to fetch public keys")?;

                let public_keys = serde_yaml::to_string(&public_keys)
                    .context("failed to serialize public keys")?;

                println!("{public_keys}");

                Ok(())
            }
        }
    }
}
