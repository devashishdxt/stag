use anyhow::{anyhow, Result};
use async_trait::async_trait;

use crate::{stag::StagContext, trait_util::Base};

use super::Event;

/// Trait to handle events generated by solo machine
#[cfg_attr(feature = "non-wasm", async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
pub trait EventHandler: Base {
    /// Handles an event
    async fn handle_event(&self, event: Event) -> Result<()>;
}

#[derive(Clone)]
/// A no-op event handler
pub struct NoopEventHandler;

#[cfg_attr(feature = "non-wasm", async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl EventHandler for NoopEventHandler {
    async fn handle_event(&self, _event: Event) -> Result<()> {
        Err(anyhow!("NoopEventHandler cannot handle events"))
    }
}

#[cfg_attr(feature = "non-wasm", async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl<C> EventHandler for C
where
    C: StagContext,
{
    async fn handle_event(&self, event: Event) -> Result<()> {
        // TODO: send event via a channel to not block the current task (i.e. the caller)
        if let Some(event_handler) = self.event_handler() {
            event_handler.handle_event(event).await?;
        }

        Ok(())
    }
}

#[cfg_attr(feature = "non-wasm", async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl<E> EventHandler for Option<E>
where
    E: EventHandler,
{
    async fn handle_event(&self, event: Event) -> Result<()> {
        if let Some(event_handler) = self {
            event_handler.handle_event(event).await?;
        }

        Ok(())
    }
}
