use anyhow::{anyhow, Result};
use async_trait::async_trait;

use crate::{stag::StagContext, trait_util::Base};

use super::Event;

/// Trait to handle events generated by solo machine
#[cfg_attr(all(not(feature = "wasm"), feature = "non-wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
pub trait EventHandler: Base {
    /// Handles an event
    async fn handle_event(&self, event: Event) -> Result<()>;
}

#[derive(Clone)]
/// A no-op event handler
pub struct NoopEventHandler;

#[cfg_attr(all(not(feature = "wasm"), feature = "non-wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl EventHandler for NoopEventHandler {
    async fn handle_event(&self, _event: Event) -> Result<()> {
        Err(anyhow!("NoopEventHandler cannot handle events"))
    }
}

#[cfg_attr(all(not(feature = "wasm"), feature = "non-wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl<C> EventHandler for C
where
    C: StagContext,
{
    async fn handle_event(&self, event: Event) -> Result<()> {
        // TODO: send event via a channel to not block the current task (i.e. the caller)
        if let Some(event_handler) = self.event_handler() {
            event_handler.handle_event(event).await?;
        }

        Ok(())
    }
}

#[cfg_attr(all(not(feature = "wasm"), feature = "non-wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl<E> EventHandler for Option<E>
where
    E: EventHandler,
{
    async fn handle_event(&self, event: Event) -> Result<()> {
        if let Some(event_handler) = self {
            event_handler.handle_event(event).await?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_noop_event_handler() {
        let event_handler = NoopEventHandler;
        assert!(event_handler.handle_event(Event::Test).await.is_err());
    }

    #[tokio::test]
    async fn test_none_event_handler() {
        let event_handler: Option<NoopEventHandler> = None;
        assert!(event_handler.handle_event(Event::Test).await.is_ok());
    }

    #[tokio::test]
    async fn test_some_event_handler() {
        let event_handler: Option<NoopEventHandler> = Some(NoopEventHandler);
        assert!(event_handler.handle_event(Event::Test).await.is_err());
    }

    struct DummyContext {
        event_handler: Option<NoopEventHandler>,
    }

    impl StagContext for DummyContext {
        type Signer = ();
        type Storage = ();
        type RpcClient = ();
        type EventHandler = NoopEventHandler;

        #[cfg_attr(coverage, no_coverage)]
        fn signer(&self) -> &Self::Signer {
            &()
        }

        #[cfg_attr(coverage, no_coverage)]
        fn set_signer(&mut self, _signer: ()) {}

        #[cfg_attr(coverage, no_coverage)]
        fn storage(&self) -> &Self::Storage {
            &()
        }

        #[cfg_attr(coverage, no_coverage)]
        fn rpc_client(&self) -> &Self::RpcClient {
            &()
        }

        fn event_handler(&self) -> Option<&Self::EventHandler> {
            self.event_handler.as_ref()
        }

        #[cfg_attr(coverage, no_coverage)]
        fn unwrap(
            self,
        ) -> (
            Self::Signer,
            Self::Storage,
            Self::RpcClient,
            Option<Self::EventHandler>,
        ) {
            ((), (), (), self.event_handler)
        }
    }

    #[tokio::test]
    async fn test_dummy_context_some_event_handler() {
        let context = DummyContext {
            event_handler: Some(NoopEventHandler),
        };
        assert!(context.handle_event(Event::Test).await.is_err());
    }

    #[tokio::test]
    async fn test_dummy_context_none_event_handler() {
        let context = DummyContext {
            event_handler: None,
        };
        assert!(context.handle_event(Event::Test).await.is_ok());
    }
}
